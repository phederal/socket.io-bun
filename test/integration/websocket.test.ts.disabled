/**
 * Integration tests for WebSocket handling
 */

import { describe, test, expect, beforeAll, afterAll, beforeEach, afterEach } from 'bun:test';
import { Hono } from 'hono';
import { websocket, wsUpgrade, io } from '../../ws';

describe('WebSocket Integration', () => {
	let server: any;
	let serverUrl: string;

	beforeAll(async () => {
		const app = new Hono();

		// Add test middleware
		app.use('/ws/*', async (c, next) => {
			c.set('user', { id: 'test-user-id', name: 'Test User' });
			c.set('session', { id: 'test-session-id', authenticated: true });
			await next();
		});

		app.get('/ws', wsUpgrade);
		app.get('/ws/*', wsUpgrade);

		// Start test server
		server = Bun.serve({
			hostname: 'localhost',
			port: 0, // Use random available port
			fetch: app.fetch,
			websocket: {
				open: websocket.open,
				message: websocket.message,
				close: websocket.close,
			},
		});

		io.setBunServer(server);
		serverUrl = `ws://localhost:${server.port}`;

		// Wait a bit for server to start
		await new Promise((resolve) => setTimeout(resolve, 100));
	});

	afterAll(() => {
		io.close();
		server?.stop();
	});

	beforeEach(() => {
		// Clear any existing event listeners
		io.removeAllListeners();
		io.sockets.removeAllListeners();
	});

	describe('Basic Connection', () => {
		test('should establish WebSocket connection', async () => {
			return new Promise<void>((resolve, reject) => {
				const timeout = setTimeout(() => reject(new Error('Connection timeout')), 3000);

				io.on('connection', (socket) => {
					clearTimeout(timeout);
					expect(socket.id).toBe('test-user-id');
					expect(socket.connected).toBe(true);
					socket.disconnect();
					resolve();
				});

				const ws = new WebSocket(`${serverUrl}/ws`);

				ws.onerror = (error) => {
					clearTimeout(timeout);
					reject(new Error(`WebSocket error: ${error}`));
				};

				ws.onclose = (event) => {
					if (event.code !== 1000) {
						clearTimeout(timeout);
						reject(
							new Error(
								`WebSocket closed unexpectedly: ${event.code} ${event.reason}`
							)
						);
					}
				};
			});
		});

		test('should handle connection to custom namespace', async () => {
			return new Promise<void>((resolve, reject) => {
				const timeout = setTimeout(
					() => reject(new Error('Namespace connection timeout')),
					3000
				);

				const chatNamespace = io.of('/chat');
				chatNamespace.on('connection', (socket) => {
					clearTimeout(timeout);
					expect(socket.nsp).toBe('/chat');
					socket.disconnect();
					resolve();
				});

				const ws = new WebSocket(`${serverUrl}/ws/chat`);

				ws.onerror = (error) => {
					clearTimeout(timeout);
					reject(new Error(`WebSocket error: ${error}`));
				};
			});
		});

		test('should reject connection without proper auth', async () => {
			return new Promise<void>((resolve, reject) => {
				const timeout = setTimeout(
					() => reject(new Error('Should have been rejected')),
					3000
				);

				// Create server without auth middleware
				const app = new Hono();
				app.get('/ws-noauth', wsUpgrade);

				const noAuthServer = Bun.serve({
					hostname: 'localhost',
					port: 0,
					fetch: app.fetch,
					websocket: {
						open: websocket.open,
						message: websocket.message,
						close: websocket.close,
					},
				});

				const ws = new WebSocket(`ws://localhost:${noAuthServer.port}/ws-noauth`);

				ws.onclose = (event) => {
					clearTimeout(timeout);
					// WebSocket might close with different codes depending on the error
					expect([1002, 3000, 1006]).toContain(event.code);
					noAuthServer.stop();
					resolve();
				};

				ws.onerror = () => {
					clearTimeout(timeout);
					noAuthServer.stop();
					resolve(); // Error is expected
				};
			});
		});
	});

	describe('Message Handling', () => {
		test('should handle basic ping/pong', async () => {
			return new Promise<void>((resolve, reject) => {
				const timeout = setTimeout(() => reject(new Error('Ping test timeout')), 3000);

				const ws = new WebSocket(`${serverUrl}/ws`);
				let handshakeComplete = false;

				ws.onopen = () => {
					// Connection opened, wait for handshake
				};

				ws.onmessage = (event) => {
					const message = event.data;

					// Handle Socket.IO handshake
					if (typeof message === 'string' && message.startsWith('0{')) {
						handshakeComplete = true;
						// Send Engine.IO ping
						ws.send('2');
						return;
					}

					// Handle Engine.IO pong
					if (handshakeComplete && message === '3') {
						clearTimeout(timeout);
						ws.close();
						resolve();
					}
				};

				ws.onerror = (error) => {
					clearTimeout(timeout);
					reject(new Error(`WebSocket error: ${error}`));
				};
			});
		});

		test('should handle Socket.IO events', async () => {
			return new Promise<void>((resolve, reject) => {
				const timeout = setTimeout(() => reject(new Error('Event test timeout')), 3000);

				io.on('connection', (socket) => {
					socket.on('test_message', (data) => {
						expect(data).toBe('Hello Server');
						socket.emit('response', 'Hello Client');
					});
				});

				const ws = new WebSocket(`${serverUrl}/ws`);
				let handshakeComplete = false;

				ws.onmessage = (event) => {
					const message = event.data;

					// Handle handshake
					if (typeof message === 'string' && message.startsWith('0{')) {
						handshakeComplete = true;
						// Send test message
						ws.send('42["test_message","Hello Server"]');
						return;
					}

					// Handle response
					if (
						handshakeComplete &&
						typeof message === 'string' &&
						message.includes('response')
					) {
						clearTimeout(timeout);
						expect(message).toContain('Hello Client');
						ws.close();
						resolve();
					}
				};

				ws.onerror = (error) => {
					clearTimeout(timeout);
					reject(new Error(`WebSocket error: ${error}`));
				};
			});
		});
	});

	describe('Error Handling', () => {
		test('should handle connection close gracefully', async () => {
			return new Promise<void>((resolve, reject) => {
				const timeout = setTimeout(() => reject(new Error('Close test timeout')), 3000);

				io.on('connection', (socket) => {
					socket.on('disconnect', (reason) => {
						clearTimeout(timeout);
						expect(reason).toBeDefined();
						resolve();
					});
				});

				const ws = new WebSocket(`${serverUrl}/ws`);

				ws.onopen = () => {
					// Close connection after a short delay to ensure connection is established
					setTimeout(() => {
						ws.close();
					}, 100);
				};

				ws.onerror = (error) => {
					clearTimeout(timeout);
					reject(new Error(`WebSocket error: ${error}`));
				};
			});
		});
	});
});
